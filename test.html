<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGL 3D Model</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <canvas id="webglCanvas"></canvas>
  <script>
    // Crear contexto WebGL
    const canvas = document.getElementById('webglCanvas');
    const gl = canvas.getContext('webgl2');

    if (!gl) {
      alert('WebGL2 no es soportado en este navegador.');
      throw new Error('WebGL2 no soportado.');
    }

    // Ajustar tamaño del canvas
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Vertex Shader (define las posiciones y las transformaciones)
    const vertexShaderSource = `
      attribute vec3 aPosition;
      attribute vec3 aNormal;

      uniform mat4 uModelMatrix;
      uniform mat4 uViewMatrix;
      uniform mat4 uProjectionMatrix;

      varying vec3 vNormal;

      void main() {
        vNormal = aNormal;
        gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aPosition, 1.0);
      }
    `;

    // Fragment Shader (define el color)
    const fragmentShaderSource = `
      precision mediump float;

      varying vec3 vNormal;

      void main() {
        vec3 lightDir = normalize(vec3(0.5, 1.0, 0.5));
        float diff = max(dot(vNormal, lightDir), 0.0);
        gl_FragColor = vec4(vec3(0.2, 0.7, 1.0) * diff, 1.0);
      }
    `;

    // Función para compilar el shader
    function compileShader(gl, source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Error compilando shader:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }

      return shader;
    }

    // Crear el programa de shaders
    function createShaderProgram(gl, vertexSource, fragmentSource) {
      const vertexShader = compileShader(gl, vertexSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(gl, fragmentSource, gl.FRAGMENT_SHADER);

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Error linkeando programa:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }

      return program;
    }

    // Crear el programa
    const program = createShaderProgram(gl, vertexShaderSource, fragmentShaderSource);
    gl.useProgram(program);

    // Crear geometría (un simple cubo como ejemplo)
    const vertices = new Float32Array([
      // Frente
      -1, -1,  1,   0,  0,  1,
       1, -1,  1,   0,  0,  1,
       1,  1,  1,   0,  0,  1,
      -1,  1,  1,   0,  0,  1,
      // Atrás
      -1, -1, -1,   0,  0, -1,
       1, -1, -1,   0,  0, -1,
       1,  1, -1,   0,  0, -1,
      -1,  1, -1,   0,  0, -1,
    ]);

    const indices = new Uint16Array([
      // Frente
      0, 1, 2,  2, 3, 0,
      // Atrás
      4, 5, 6,  6, 7, 4,
    ]);

    // Crear buffers
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    // Atributos de posición
    const positionLocation = gl.getAttribLocation(program, 'aPosition');
    gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 6 * 4, 0);
    gl.enableVertexAttribArray(positionLocation);

    // Atributos de normales
    const normalLocation = gl.getAttribLocation(program, 'aNormal');
    gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 6 * 4, 3 * 4);
    gl.enableVertexAttribArray(normalLocation);

    // Uniformes para matrices
    const uModelMatrix = gl.getUniformLocation(program, 'uModelMatrix');
    const uViewMatrix = gl.getUniformLocation(program, 'uViewMatrix');
    const uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');

    // Función para crear matrices de transformación
    function identityMatrix() {
      return new Float32Array([
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1,
      ]);
    }

    function translate(matrix, x, y, z) {
      const m = identityMatrix();
      m[12] = x;
      m[13] = y;
      m[14] = z;
      return multiplyMatrices(matrix, m);
    }

    function rotateY(matrix, angle) {
      const m = identityMatrix();
      const cosAngle = Math.cos(angle);
      const sinAngle = Math.sin(angle);
      m[0] = cosAngle;
      m[2] = sinAngle;
      m[8] = -sinAngle;
      m[10] = cosAngle;
      return multiplyMatrices(matrix, m);
    }

    function multiplyMatrices(a, b) {
      const result = new Float32Array(16);
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          result[i * 4 + j] = 0;
          for (let k = 0; k < 4; k++) {
            result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
          }
        }
      }
      return result;
    }

    // Crear matrices
    const modelMatrix = identityMatrix();
    const viewMatrix = identityMatrix();
    const projectionMatrix = identityMatrix();

    // Configurar cámara
    function lookAt(eye, target, up) {
      const zaxis = normalize(subtract(eye, target));
      const xaxis = normalize(cross(up, zaxis));
      const yaxis = cross(zaxis, xaxis);

      const m = identityMatrix();
      m[0] = xaxis[0];
      m[1] = xaxis[1];
      m[2] = xaxis[2];
      m[4] = yaxis[0];
      m[5] = yaxis[1];
      m[6] = yaxis[2];
      m[8] = -zaxis[0];
      m[9] = -zaxis[1];
      m[10] = -zaxis[2];
      m[12] = -dot(xaxis, eye);
      m[13] = -dot(yaxis, eye);
      m[14] = dot(zaxis, eye);
      return m;
    }

    function normalize(v) {
      const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
      return [v[0] / len, v[1] / len, v[2] / len];
    }

    function subtract(a, b) {
      return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
    }

    // Matriz de proyección
    function perspective(fovy, aspect, near, far) {
      const top = Math.tan(fovy * 0.5) * near;
      const bottom = -top;
      const left = bottom * aspect;
      const right = top * aspect;
      const m = new Float32Array(16);
      m[0] = (2 * near) / (right - left);
      m[5] = (2 * near) / (top - bottom);
      m[10] = -(far + near) / (far - near);
      m[11] = -1;
      m[14] = -(2 * far * near) / (far - near);
      return m;
    }

    // Configuración de matrices
    const fovy = Math.PI / 4;
    const aspect = canvas.width / canvas.height;
    const near = 0.1;
    const far = 100.0;

    const cameraPosition = [0, 2, 5];
    const targetPosition = [0, 0, 0];
    const upDirection = [0, 1, 0];

    const projection = perspective(fovy, aspect, near, far);
    const view = lookAt(cameraPosition, targetPosition, upDirection);

    // Animación y renderizado
    function animate(time) {
      time *= 0.001;

      // Rotar el modelo
      rotateY(modelMatrix, 0.01);

      // Pasar las matrices a los shaders
      gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix);
      gl.uniformMatrix4fv(uViewMatrix, false, view);
      gl.uniformMatrix4fv(uProjectionMatrix, false, projection);

      // Limpiar pantalla
      gl.clearColor(0.1, 0.1, 0.1, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // Dibujar
      gl.bindVertexArray(vao);
      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

      requestAnimationFrame(animate);
    }

    // Habilitar el buffer de profundidad
    gl.enable(gl.DEPTH_TEST);

    // Iniciar la animación
    animate(0);
  </script>
</body>
</html>
