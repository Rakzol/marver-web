<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGL 3D Model</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <canvas id="webglCanvas"></canvas>
  <script>
    // Crear contexto WebGL
    const canvas = document.getElementById('webglCanvas');
    const gl = canvas.getContext('webgl2');

    if (!gl) {
      alert('WebGL2 no es soportado en este navegador.');
      throw new Error('WebGL2 no soportado.');
    }

    // Ajustar tamaño del canvas
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Vertex Shader (define las posiciones y las transformaciones)
    const vertexShaderSource = `
      attribute vec3 aPosition;
      attribute vec3 aNormal;

      uniform mat4 uModelMatrix;
      uniform mat4 uViewMatrix;
      uniform mat4 uProjectionMatrix;

      varying vec3 vNormal;

      void main() {
        vNormal = aNormal;
        gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aPosition, 1.0);
      }
    `;

    // Fragment Shader (define el color y la iluminación)
    const fragmentShaderSource = `
      precision mediump float;

      varying vec3 vNormal;

      void main() {
        vec3 lightDir = normalize(vec3(0.5, 1.0, 0.5)); // Dirección de la luz
        float diff = max(dot(vNormal, lightDir), 0.0);  // Cálculo del producto punto
        gl_FragColor = vec4(vec3(0.2, 0.7, 1.0) * diff, 1.0); // Color final
      }
    `;

    // Función para compilar el shader
    function compileShader(gl, source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Error compilando shader:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }

      return shader;
    }

    // Crear el programa de shaders
    function createShaderProgram(gl, vertexSource, fragmentSource) {
      const vertexShader = compileShader(gl, vertexSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(gl, fragmentSource, gl.FRAGMENT_SHADER);

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Error linkeando programa:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }

      return program;
    }

    // Crear el programa
    const program = createShaderProgram(gl, vertexShaderSource, fragmentShaderSource);
    gl.useProgram(program);

    // Crear geometría (un simple cubo como ejemplo)
    const vertices = new Float32Array([
      // Frente
      -1, -1,  1,   0,  0,  1,
       1, -1,  1,   0,  0,  1,
       1,  1,  1,   0,  0,  1,
      -1,  1,  1,   0,  0,  1,
      // Atrás
      -1, -1, -1,   0,  0, -1,
       1, -1, -1,   0,  0, -1,
       1,  1, -1,   0,  0, -1,
      -1,  1, -1,   0,  0, -1,
    ]);

    const indices = new Uint16Array([
      // Frente
      0, 1, 2,  2, 3, 0,
      // Atrás
      4, 5, 6,  6, 7, 4,
    ]);

    // Crear buffers
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    // Atributos de posición
    const positionLocation = gl.getAttribLocation(program, 'aPosition');
    gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 6 * 4, 0);
    gl.enableVertexAttribArray(positionLocation);

    // Atributos de normales
    const normalLocation = gl.getAttribLocation(program, 'aNormal');
    gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 6 * 4, 3 * 4);
    gl.enableVertexAttribArray(normalLocation);

    // Uniformes para matrices
    const uModelMatrix = gl.getUniformLocation(program, 'uModelMatrix');
    const uViewMatrix = gl.getUniformLocation(program, 'uViewMatrix');
    const uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');

    // Función para crear matrices de transformación
    function identityMatrix() {
      return new Float32Array([
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1,
      ]);
    }

    function rotateY(matrix, angle) {
      const m = identityMatrix();
      const cosAngle = Math.cos(angle);
      const sinAngle = Math.sin(angle);
      m[0] = cosAngle;
      m[2] = sinAngle;
      m[8] = -sinAngle;
      m[10] = cosAngle;
      return multiplyMatrices(matrix, m);
    }

    function multiplyMatrices(a, b) {
      const result = new Float32Array(16);
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          result[i * 4 + j] = 0;
          for (let k = 0; k < 4; k++) {
            result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
          }
        }
      }
      return result;
    }

    // Funciones para vectores
    function cross(a, b) {
      return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]
      ];
    }

    // Crear la matriz de vista
    function lookAt(eye, target, up) {
      const zaxis = normalize(subtract(eye, target));  // Dirección de la cámara
      const xaxis = normalize(cross(up, zaxis));       // Eje X
      const yaxis = cross(zaxis, xaxis);                // Eje Y

      const m = identityMatrix();
      m[0] = xaxis[0];
      m[1] = xaxis[1];
      m[2] = xaxis[2];
      m[4] = yaxis[0];
      m[5] = yaxis[1];
      m[6] = yaxis[2];
      m[8] = -zaxis[0];
      m[9] = -zaxis[1];
      m[10] = -zaxis[2];

      const eyeVec = [-dot(xaxis, eye), -dot(yaxis, eye), dot(zaxis, eye)];
      m[12] = eyeVec[0];
      m[13] = eyeVec[1];
      m[14] = eyeVec[2];

      return m;
    }

    function normalize(v) {
      const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
      return [v[0] / length, v[1] / length, v[2] / length];
    }

    function subtract(a, b) {
      return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
    }

    function dot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    // Función de animación
    let angle = 0;
    function animate() {
      // Limpiar el canvas
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);

      // Rotar el modelo
      angle += 0.01;
      const modelMatrix = identityMatrix();
      const rotatedModelMatrix = rotateY(modelMatrix, angle);

      // Matriz de proyección
      const projectionMatrix = new Float32Array([
        2 / canvas.width, 0, 0, 0,
        0, 2 / canvas.height, 0, 0,
        0, 0, -2 / (100 - 0.1), 0,
        0, 0, -(100 + 0.1) / (100 - 0.1), 1
      ]);

      // Matriz de vista
      const viewMatrix = lookAt([0, 0, 5], [0, 0, 0], [0, 1, 0]);

      // Enviar las matrices al shader
      gl.uniformMatrix4fv(uModelMatrix, false, rotatedModelMatrix);
      gl.uniformMatrix4fv(uViewMatrix, false, viewMatrix);
      gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);

      // Dibujar el modelo
      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

      // Llamar a la siguiente iteración de la animación
      requestAnimationFrame(animate);
    }

    // Iniciar la animación
    animate();
  </script>
</body>
</html>
